{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCallback, useContext, useState } from \"react\";\nimport { AppContext } from \"../utils/context\";\nimport { fakeFetch } from \"../utils/fetch\";\nexport function useCustomFetch() {\n  _s();\n\n  const [loading, setLoading] = useState(false);\n  const {\n    setError\n  } = useContext(AppContext);\n  const fetchWithCache = useCallback(async (endpoint, params) => {\n    try {\n      setLoading(true);\n      const response = await fakeFetch(endpoint, params);\n      return response;\n    } catch (error) {\n      setError(error);\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  }, [setError]);\n  const fetchWithoutCache = useCallback(async (endpoint, params) => {\n    try {\n      setLoading(true);\n      const response = await fakeFetch(endpoint, params);\n      return response;\n    } catch (error) {\n      setError(error);\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  }, [setError]);\n  return {\n    fetchWithCache,\n    fetchWithoutCache,\n    loading\n  };\n}\n\n_s(useCustomFetch, \"wj9Bwq0DJF84JXPNF998jcS8thg=\");","map":{"version":3,"names":["useCallback","useContext","useState","AppContext","fakeFetch","useCustomFetch","loading","setLoading","setError","fetchWithCache","endpoint","params","response","error","fetchWithoutCache"],"sources":["/Users/varshithkola/Desktop/ramp-fe-challenge/src/hooks/useCustomFetch.ts"],"sourcesContent":["import { useCallback, useContext, useState } from \"react\";\nimport { AppContext } from \"../utils/context\";\nimport { fakeFetch, RegisteredEndpoints } from \"../utils/fetch\";\n\nexport function useCustomFetch() {\n  const [loading, setLoading] = useState(false);\n  const { setError } = useContext(AppContext);\n\n  const fetchWithCache = useCallback(\n    async <TData, TParams extends object>(endpoint: RegisteredEndpoints, params?: TParams): Promise<TData> => {\n      try {\n        setLoading(true);\n        const response = await fakeFetch<TData, TParams>(endpoint, params);\n        return response;\n      } catch (error) {\n        setError(error as string);\n        throw error;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [setError]\n  );\n\n  const fetchWithoutCache = useCallback(\n    async <TData, TParams extends object>(endpoint: RegisteredEndpoints, params?: TParams): Promise<TData> => {\n      try {\n        setLoading(true);\n        const response = await fakeFetch<TData, TParams>(endpoint, params);\n        return response;\n      } catch (error) {\n        setError(error as string);\n        throw error;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [setError]\n  );\n\n  return { fetchWithCache, fetchWithoutCache, loading };\n}\n"],"mappings":";;AAAA,SAASA,WAAT,EAAsBC,UAAtB,EAAkCC,QAAlC,QAAkD,OAAlD;AACA,SAASC,UAAT,QAA2B,kBAA3B;AACA,SAASC,SAAT,QAA+C,gBAA/C;AAEA,OAAO,SAASC,cAAT,GAA0B;EAAA;;EAC/B,MAAM,CAACC,OAAD,EAAUC,UAAV,IAAwBL,QAAQ,CAAC,KAAD,CAAtC;EACA,MAAM;IAAEM;EAAF,IAAeP,UAAU,CAACE,UAAD,CAA/B;EAEA,MAAMM,cAAc,GAAGT,WAAW,CAChC,OAAsCU,QAAtC,EAAqEC,MAArE,KAA0G;IACxG,IAAI;MACFJ,UAAU,CAAC,IAAD,CAAV;MACA,MAAMK,QAAQ,GAAG,MAAMR,SAAS,CAAiBM,QAAjB,EAA2BC,MAA3B,CAAhC;MACA,OAAOC,QAAP;IACD,CAJD,CAIE,OAAOC,KAAP,EAAc;MACdL,QAAQ,CAACK,KAAD,CAAR;MACA,MAAMA,KAAN;IACD,CAPD,SAOU;MACRN,UAAU,CAAC,KAAD,CAAV;IACD;EACF,CAZ+B,EAahC,CAACC,QAAD,CAbgC,CAAlC;EAgBA,MAAMM,iBAAiB,GAAGd,WAAW,CACnC,OAAsCU,QAAtC,EAAqEC,MAArE,KAA0G;IACxG,IAAI;MACFJ,UAAU,CAAC,IAAD,CAAV;MACA,MAAMK,QAAQ,GAAG,MAAMR,SAAS,CAAiBM,QAAjB,EAA2BC,MAA3B,CAAhC;MACA,OAAOC,QAAP;IACD,CAJD,CAIE,OAAOC,KAAP,EAAc;MACdL,QAAQ,CAACK,KAAD,CAAR;MACA,MAAMA,KAAN;IACD,CAPD,SAOU;MACRN,UAAU,CAAC,KAAD,CAAV;IACD;EACF,CAZkC,EAanC,CAACC,QAAD,CAbmC,CAArC;EAgBA,OAAO;IAAEC,cAAF;IAAkBK,iBAAlB;IAAqCR;EAArC,CAAP;AACD;;GArCeD,c"},"metadata":{},"sourceType":"module"}